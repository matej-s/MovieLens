---
title: "Capstone Project: Movielens Recommender System"
author: "Matej Salamunić"
date: "02/11/2020"
output: pdf_document
---
## 1 Introduction  

This project aims to create a movie recommendation system using the MovieLens dat aset. The complete MovieLens data set contains 27 million ratings on 58,000 movies by 280,000 users (https://grouplens.org/datasets/movielens/latest/). To make computation easier this project used 10 million subset of MovieLens data set with 10 million ratings on 10,000 movies by 72,000 users (https://grouplens.org/datasets/movielens/10m/). The 10M MovieLens is downloaded and then data is explored to understand the features and the structure of the data set. After data exploration and visualization in data preparation step movie ID, user ID, movie title, rating and released year are taken for the model analysis.

To develop movie recommendation system algorithms 10M MovieLens data set is randomly divided into a set called “edx” (90%), and a “validation” set (10%). The “edx” set is split again into two subsets used for training (“train_edx“, 80%) and testing (“test_edx“, 20%). Models are first trained on “train_edx” and tested on “test_edx” data set. 
Linear model with movie, user and release year effect is evaluated first, then regularization model that penalize samples with few ratings. Finally, the matrix factorization model based on recosystem package is evaluated on the user - movie matrix. To compare the performance of different algorithms Root Mean Square Error (RMSE) was used.

For two systems with lowest RMSE value, regularization model and matrix factorization model, final evaluation is performed against the “validation” set. At the end rating prediction is performed for the project best recommendation system based on the matrix factorization model.

Information on the available scripts, implementation system and processing time can be found in the appendix.


## 2 Method and Analysis  


### 2.1 Download Data and Generate Data Sets 

This section describes the required packages in the project, the data source used and the data sets created from the sources with which the evaluation of different algorithms was performed.


### 2.1.1 Install packages and load library  

First it is necessary to download and install the R packages used in this project (tidyverse, lubridate, caret, data.table, dslabs, ggthemes, scales, recosystem, knitr, kableExtra, ggplot2, gridExtra, jjb, naniar). After installation, to be used they have to be loaded into the session.

```{r cache = FALSE, echo=FALSE, message=FALSE, warning=FALSE}

#2.1.1 Install packages and call library for the project
if(!require(tidyverse)) install.packages("tidyverse", repos = "http://cran.us.r-project.org")
if(!require(lubridate)) install.packages("lubridate", repos = "http://cran.us.r-project.org")
if(!require(caret)) install.packages("caret", repos = "http://cran.us.r-project.org")
if(!require(data.table)) install.packages("data.table", repos = "http://cran.us.r-project.org")
if(!require(dslabs)) install.packages("dslabs", repos = "http://cran.us.r-project.org")
if(!require(ggthemes))  install.packages("ggthemes", repos = "http://cran.us.r-project.org")
if(!require(scales)) install.packages("scales", repos = "http://cran.us.r-project.org")
if(!require(recosystem)) install.packages("recosystem", repos = "http://cran.us.r-project.org")
if(!require(knitr)) install.packages("knitr", repos = "http://cran.us.r-project.org")
if(!require(kableExtra)) install.packages("kableExtra", repos = "http://cran.us.r-project.org")
if(!require(ggplot2)) install.packages("ggplot2", repos = "http://cran.us.r-project.org")
if(!require(gridExtra)) install.packages("gridExtra", repos = "http://cran.us.r-project.org")
if(!require(jjb)) install.packages("jjb", repos = "http://cran.us.r-project.org")
if(!require(naniar)) install.packages("naniar", repos = "http://cran.us.r-project.org")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
#2.1.1 Load library 
library(tidyverse)
library(lubridate)
library(caret)
library(data.table)
library(dslabs)
library(ggthemes)
library(scales)
library(recosystem)
library(knitr)
library(kableExtra)
library(ggplot2)
library(gridExtra)
library(jjb)
library(naniar)

#make directory figs to save figures
mkdir("figs")
```

### 2.1.2 Download Data  

The data source for the project is a 10M version of the MovieLens data sets (http://files.grouplens.org/datasets/movielens/ml-10m.zip) generated by the GroupLens research lab.  The 10M MovieLens files are downloaded so that can be used to create the data sets used in the project.


### 2.1.3 Generate Data Sets  

Split the downloaded MovieLens data set into **edx** set and **validation** set. The edx set will be 90% and validation set will be 10% of MovieLens data set. Then, split the edx set in two parts - **train_edx** with 80% and **test_edx** with 20% of edx set data.

```{r cache = FALSE, include=FALSE, echo=FALSE, message=FALSE}

#2.1.2 Download data
#download data
# MovieLens 10M dataset:
# https://grouplens.org/datasets/movielens/10m/
# http://files.grouplens.org/datasets/movielens/ml-10m.zip
dl <- tempfile()
download.file("http://files.grouplens.org/datasets/movielens/ml-10m.zip", dl)

#2.1.3 Generate datasets
#Split the downloaded MovieLens dataset into 
#edx set 90% and 
#validation set 10% 
ratings <- fread(text = gsub("::", "\t", readLines(unzip(dl, "ml-10M100K/ratings.dat"))),
                 col.names = c("userId", "movieId", "rating", "timestamp"))

movies <- str_split_fixed(readLines(unzip(dl, "ml-10M100K/movies.dat")), "\\::", 3)
colnames(movies) <- c("movieId", "title", "genres")

## if using R 3.6 or earlier
##movies <- as.data.frame(movies) %>% mutate(movieId = as.numeric(levels(movieId))[movieId],
##                                           title = as.character(title),
##                                           genres = as.character(genres))

# if using R 4.0 or later
movies <- as.data.frame(movies) %>% mutate(movieId = as.numeric(movieId),
                                           title = as.character(title),
                                           genres = as.character(genres))

movielens <- left_join(ratings, movies, by = "movieId")


# Validation set will be 10% of MovieLens data
set.seed(1, sample.kind="Rounding")
# if using R 3.5 or earlier, use `set.seed(1)` instead
test_index <- createDataPartition(y = movielens$rating, times = 1, p = 0.1, list = FALSE)
edx <- movielens[-test_index,]
temp <- movielens[test_index,]


# Make sure userId and movieId in validation set are also in edx set
validation <- temp %>%
  semi_join(edx, by = "movieId") %>%
  semi_join(edx, by = "userId")
# Add rows removed from validation set back into edx set
removed <- anti_join(temp, validation)
edx <- rbind(edx, removed)

rm(dl, ratings, movies, test_index, temp, movielens, removed)


#Split edx set in two sets -
#train_edx with 80% and 
#test_edx with 20% of edx set data

set.seed(1, sample.kind="Rounding")

edx_test_index <- createDataPartition(y = edx$rating, times = 1, p = 0.2, list = FALSE)
train_edx <- edx[-edx_test_index, ]
temp_2 <- edx[edx_test_index, ]

#Make sure userId and movieId in test_edx set are also in train_edx set
test_edx <- temp_2 %>%
  semi_join(train_edx, by = "movieId") %>%
  semi_join(train_edx, by = "userId")

# Add rows removed from test_edx set back into train set
remove <- anti_join(temp_2, test_edx)
train_edx <- rbind(train_edx, remove)

rm(edx_test_index, temp_2, remove)
```


### 2.2  Exploration and Vizualization  

Insight into the basic characteristics and properties of the data is obtained by inspecting the edx data set.

```{r echo=FALSE, warning=FALSE}
#head(edx)
kable(edx[1:5, ], caption="edx") %>% kable_styling(latex_options = "hold_position", font_size = 8)

```


```{r echo=TRUE, results='hide', message=FALSE, warning=FALSE}
str(edx)

#Classes ‘data.table’ and 'data.frame':	9000055 obs. of  6 variables:
# $ userId   : int  1 1 1 1 1 1 1 1 1 1 ...
# $ movieId  : num  122 185 292 316 329 355 356 362 364 370 ...
# $ rating   : num  5 5 5 5 5 5 5 5 5 5 ...
# $ timestamp: int  838985046 838983525 838983421 838983392 838983392 838984474 838983653 ...
# $ title    : chr  "Boomerang (1992)" "Net, The (1995)" "Outbreak (1995)"  ...
# $ genres   : chr  "Comedy|Romance" "Action|Crime|Thriller" "Action|Drama|Sci-Fi|Thriller" ...

```

Initial result show that edx has 9,000,055 rows for 6 columns (userId, movieId, rating, timestamp, title, geners). In the edx data set each row has one observation and the column names are the features name. The users information are stored in userId column. The movie information is in movieId and title columns, and there is a movie release year at the end of the title string. The rating date is available in timestamp and each movie has one or more genre in the genres column.


### 2.2.1  About Rating  

To see how often a certain rank is used, which are used the most and which the least, we will calculate the total number for each rank in the edx data set.

```{r cache = FALSE, echo=FALSE, message=FALSE, warning=FALSE, results='asis', fig.height = 2, fig.width = 4}

#head(edx)
edx %>% group_by(rating) %>% 
  summarise(count=n()) %>%
  ggplot(aes(x=rating, y=count)) + 
  geom_col()+
  xlab("rating") +
  ylab("count") +
  theme(text = element_text(size=9)) + 
  scale_y_continuous(labels = comma) +
  scale_x_continuous(breaks=seq(0, 5, by= 0.5)) +
  ggtitle("Rating Count")+
  theme(plot.title = element_text(size = 9))

kable(edx %>% group_by(rating) %>% summarize(n=n()) %>% t(), format.args = list(big.mark = ",", scientific = FALSE) , caption= "Rating count", align = "llllllllll") %>% kable_styling(latex_options = "hold_position", font_size = 8)

```

From the graph above, it can be seen that users mostly use average ratings (3 stars and 4 stars) and all half stars ranks are less frequent than full stars.


### 2.2.2  About MovieId  

```{r echo=TRUE, warning=FALSE, results='asis'}
format(n_distinct(edx$movieId), big.mark= ',')
```
There are 10,677 different movies in the edx data set and theirs distribution by number of rankings is shown in the graph below.

```{r cache = FALSE, echo=FALSE, message=FALSE, warning=FALSE, results='asis', fig.height = 2, fig.width = 4}
#Ratings distribution by movie
edx %>% group_by(movieId) %>%
  summarise(n=n()) %>%
  ggplot(aes(n)) +
  geom_histogram(bins=20) +
  ggtitle("Ratings distribution by movie")+
  theme(plot.title = element_text(size = 9)) +
  scale_x_log10() +
  theme(text = element_text(size=9)) +
  xlab("rating count") +
  ylab("movieId count") 
```

A small number of movies have only one rating or over 1,000 ratings and the majority movies have been rated between 50 and 1,000 times.


### 2.2.3 About UserId  

```{r echo=TRUE, warning=FALSE, results='asis'}
format(n_distinct(edx$userId), big.mark= ',')
```
There are 69,878 different users in the edx set. 

```{r cache = FALSE, echo=FALSE, message=FALSE, warning=FALSE, results='asis', fig.height = 2, fig.width = 4}
#Ratings distribution by user
edx %>% group_by(userId) %>%
  summarise(n=n()) %>%
  ggplot(aes(n)) +
  geom_histogram(bins=20) +
  scale_x_log10() +
  theme(text = element_text(size=9)) +
  xlab("rating count") +
  ylab("userId count") +
  ggtitle("Ratings distribution by user")+
  theme(plot.title = element_text(size = 9))
```

Only few users rated more than a 1,000 times or less than 10 times. Most users rated movies between 30 and 100 times.


### 2.2.4  About Year Rated (timestamp)  

The timestamp variable represents the time and date in which the rating was provided so we can use year of rating from the timestamp. In the figure below we can see the distribution of the average rating according to the year in which the rating was given.

```{r cache = FALSE, echo=FALSE, message=FALSE, warning=FALSE, results='asis', fig.height = 2, fig.width = 4}
#Mean ratings by year rated
edx %>% mutate(year_rated = year(as_datetime(timestamp))) %>%
    group_by(year_rated) %>%
    summarise(rating =mean(rating)) %>% 
    ggplot(aes(year_rated,rating)) +
    geom_point() +
    geom_smooth(method = 'loess', se = FALSE, span = 2/3) +
    theme(text = element_text(size=9)) +
    ggtitle("Mean ratings by year rated") +
    theme(plot.title = element_text(size = 9))

```

Looking at the year the rating was made there is no significant impact on the average rating, especially in the last 20 years.


### 2.2.5 About Genres  

In the data set movies are associated with several different values for the genre variable. Thus e.g. movie Outbreak with movieId 292 has 4 separated values in the genres variable (Action|Drama|Sci-Fi|Thriller). 

```{r echo=TRUE, warning=FALSE, results='asis'}
n_distinct((edx$genres))
```

The edx data set has 797 distinct genres. The previously described genre variable in the edx data set has over 700 different values. In order to examine an individual genres characteristic, we will split the genres information into multiple row into the genres_edx data set.

```{r cache = FALSE, echo=TRUE, warning=FALSE}
genres_edx <- edx %>% separate_rows(genres, sep ="\\|")
```

```{r cache = FALSE, echo=FALSE, warning=FALSE}
table_2 <- tibble(data_set="edx", rows=format(nrow(edx), big.mark= ','))
table_2 <- bind_rows(table_2, tibble(data_set="genres_edx", rows=format(nrow(genres_edx), big.mark= ',')))
print.data.frame(table_2)
```

The edx data set has about 9 million rows and when we separate the data in the genre column we get a data set (genres_edx) of 23 million rows. This data transformation duplicates the ratings of an individual movie as many times as there are different genre values and in this data set (genres_edx) this affects the film rating information. 

The images below explore the rating numbers and number of movies in each genre from the genres_edx dataset, so one movie can appear in several genres.

```{r cache = FALSE, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}
#Number of ratings genres
p1 <-  genres_edx %>%
  group_by(genres) %>% 
  summarize(n=n()) %>%
  mutate(genres=reorder(genres,n)) %>%
  ggplot(aes(x=n, y=genres)) +  
  geom_bar(stat = "identity") + 
  ggtitle("Number of ratings genres") +
  theme(plot.title = element_text(size = 7)) +
  xlab("number of ratings") +
  ylab("genres") +
  scale_x_continuous(labels = comma) +
  theme(text = element_text(size=7))

#Distinct movies by genres
p2 <- genres_edx %>%
  group_by(genres) %>% 
  summarize(n=n_distinct(movieId)) %>%
  mutate(genres=reorder(genres,n)) %>%
  ggplot(aes(x=n, y=genres)) +  
  geom_bar(stat = "identity") + 
  ggtitle("Distinct movies by genres") + 
  theme(plot.title = element_text(size = 7)) + 
  xlab("distinct movies") +
  ylab("genres") +
  scale_x_continuous(labels = comma) +
  theme(text = element_text(size=7))

grid.arrange(p1, p2, ncol = 2,  widths=c(1, 1))
```

Drama and Comedy are the highest rated types of genres, but at the same time these two genres have a larger number of movies than other genres. Therefore we cannot say that one type ranks more often than another. 

The following graph shows the average rating per each genres.

```{r cache = FALSE, echo=FALSE, message=FALSE, warning=FALSE, include=FALSE}
png(file="figs/fig_1.png", width=480, height=300)
#average rating per each genres
genres_edx %>%
  group_by(genres) %>% 
  boxplot(rating ~ genres, ., las=2, cex.axis = 0.8) 
dev.off()
```

```{r cache = FALSE, echo=FALSE, message=FALSE, warning=FALSE}
include_graphics("figs/fig_1.png", auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE), dpi=NA)
```

Some genres have a higher average rating (Film-Noir, War) while some are below average (Horror, Sci-Fi). But overall it’s not a big difference between genres given the average rating per genre.


### 2.2.6  About Movie Relase Year  

The title column in the edx data set contains the title of the movie and also the movie release year information which can be extracted into a special column (movie_relase_year).

```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#movie release year
movie_relase_year_edx <- edx %>%
  mutate (movie_relase_year=as.numeric(str_sub(title, -5, -2)))
```

```{r cache = FALSE, echo=FALSE, message=FALSE, warning=FALSE}
kable(movie_relase_year_edx[1:5, ] ) %>% kable_styling(latex_options = "hold_position", font_size = 8)
```

The figures below show the distribution of the average rating of movies according to the year in which the movie was released.

```{r cache = FALSE, echo=FALSE, message=FALSE, warning=FALSE, include=FALSE}
png(file="figs/fig_2.png", width=480, height=300)
#average rating of movies according to release year
movie_relase_year_edx %>% 
  group_by(movie_relase_year) %>%
  boxplot(rating ~ movie_relase_year, ., las=2, cex.axis = 0.6)
dev.off()
```

```{r cache = FALSE, echo=FALSE, message=FALSE, warning=FALSE}
include_graphics("figs/fig_2.png", auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE), dpi=NA)
```

```{r cache = FALSE, echo=FALSE, message=FALSE, warning=FALSE, results='asis', fig.height = 2, fig.width = 4}
#Mean ratings by movie relase year
edx %>% mutate (movie_relase_year=as.numeric(str_sub(title, -5, -2))) %>%
  group_by(movie_relase_year) %>%
  summarise(rating = mean(rating)) %>% 
  ggplot(aes(movie_relase_year, rating)) +
  geom_point() +
  geom_smooth(method = 'loess', span = 2/3) +
  ggtitle("Mean ratings by movie relase year") +
  theme(plot.title = element_text(size = 9)) 

```

Given the year the film was released, it can been seen that movies in recent years, since 1995, have received on average a lower rating than older films.


### 2.2.7 User - Movie Matrix  

Users only rate the movies they want to rate, so not every movie is rated by the all users and that can be seen in the user - movie matrix.

```{r echo=TRUE, results='hide', message=FALSE, warning=FALSE}
#user - movie rating matrix 
matrix_all_edx <- edx %>% 
  select(userId, movieId, rating) %>%
  mutate(rating = 1) %>% 
  spread(movieId, rating) %>% as.matrix()
```

The table below shows how much empty data there is in the matrix (matrix_all_edx).
```{r echo=FALSE, message=FALSE, warning=FALSE}

#all
lenght_2 <- length(matrix_all_edx)

#empty
lenght_2_na <- length(matrix_all_edx[is.na(matrix_all_edx)])

#filled
lenght_2_not_na <- length(matrix_all_edx[!is.na(matrix_all_edx)])

table_2_7 <- tibble(data="all", rows=format(lenght_2, big.mark= ','))
table_2_7 <- bind_rows(table_2_7, tibble(data="empty", rows=format(lenght_2_na, big.mark= ',')))
table_2_7 <- bind_rows(table_2_7, tibble(data="filled", rows=format(lenght_2_not_na, big.mark= ',')))
print.data.frame(table_2_7)
```

The figure below shows for 100 randomly selected users and movies which movie is rated by which user (filled fields) and unrated films are those with empty fields.

```{r cache = FALSE, echo=FALSE, message=FALSE, warning=FALSE, include=FALSE}

png(file="figs/fig_3.png", width=480, height=270)
#user - movie matrix
edx %>% filter(userId %in% sample(unique(edx$userId), 100)) %>%
  select(userId, movieId, rating) %>%
  mutate(rating = 1) %>%
  spread(movieId, rating) %>% 
  select(sample(ncol(.), 100)) %>% 
  as.matrix() %>% t(.) %>%
  image(1:100, 1:100,. , xlab="movies", ylab="users")
  abline(h=0:100+0.5, v=0:100+0.5, col = "grey")
  #title("user - movie matrix") 

dev.off()
```

```{r cache = FALSE, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}
include_graphics("figs/fig_3.png", auto_pdf = getOption("knitr.graphics.auto_pdf", FALSE), dpi=NA)
```

The edx data set has 10,677 different movies, 69,878 different users and has about 9 million lines (rating).
If each user ranked each movie, the edx data set would have more than 700 million rows. Thus, it follows that only less than 2% of all possible rankings are present, and the user - movie matrix is about 98% sparse.


### 2.3 Preprocessing, Data Cleaning and Prepare   

The data exploration and visualization showed that some movies were rated more than others, and that some users ranked more often than others. Looking at the movie release year, it was noticed that newer movies have a slightly lower rating on average. Movie genres and the year when the movie is ranked do not significantly affect the average rating. Also, it has been observed that movies, regardless of the release year or the genre of the movie, are rarely ranked with ratings lower than 1.5, and that the half star ratings are less common than whole star ratings. If we transform an edx data set into a user - movie matrix a large amount of cells remain empty.

Based on the data exploration movieId, userId, year of relase are information that will be used for the machine learning algorithms evaluation, so timestamp and generes can be excluded form data sets.

```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE }
#preparing data sets
edx <- edx %>% select(userId, movieId, rating, title) %>%
               mutate (movie_relase_year=as.numeric(str_sub(title, -5, -2))) 

train_edx <- train_edx %>% select(userId, movieId, rating, title) %>%
               mutate (movie_relase_year=as.numeric(str_sub(title, -5, -2))) 

test_edx  <- test_edx  %>% select(userId, movieId, rating, title) %>% 
               mutate (movie_relase_year=as.numeric(str_sub(title, -5, -2)))

validation <- validation %>% select(userId, movieId, rating, title) %>% 
               mutate (movie_relase_year=as.numeric(str_sub(title, -5, -2)))

```

```{r echo=FALSE, message=FALSE, warning=FALSE, results='asis' }
kable(edx[1:5, ], caption='modeling information' ) %>% kable_styling(latex_options = "hold_position", font_size = 8)
```
  

```{r  echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

table_2_3_1 <- tibble(MovieLens_split="edx", rows=format(nrow(edx), big.mark= ',' ))
table_2_3_1 <- bind_rows(table_2_3_1, tibble(MovieLens_split="validation", rows=format(nrow(validation), big.mark= ',' )))

table_2_3_1b <- tibble(edx_split="train_edx", rows=format(nrow(train_edx), big.mark= ',' ))
table_2_3_1b <- bind_rows(table_2_3_1b, tibble(edx_split="test_edx", rows=format(nrow(test_edx), big.mark= ',' )))

kable( list(table_2_3_1, table_2_3_1b), caption = 'Data sets', booktabs = TRUE, valign = 't')  %>% kable_styling(latex_options = "hold_position", font_size = 8)
```


### 2.4 Modeling Approach  
  
First, a basic model was made which is just the mean of the observed values. The following three models add a movie effect, a user effect, and a movie release year effect. The fifth  and sixth model uses regularization parameter that penalizes movies with few ratings. The fifth model uses a user and movie effect with regularization parameter and sixth model uses a user, movie and movie release year effect with regularization parameter. The seventh model uses userId, movieId and ratings data for the matrix factorization model from recosystem package that use cross validation to tune the model parameters.

Each model is trained on "train_edx" and then tested on "test_edx" data and finally the resulting Root Mean Square Error (RMSE) value of the model is calculated.
```{r  cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE, results='hide'}
#function that calculates RMSE error
RMSE <- function(true_ratings, predicted_ratings){
  sqrt(mean((true_ratings - predicted_ratings)^2))
}
```

Assessments of these models is based on their resulting Root Mean Square Error (RMSE). The RMSE value was calculated for each model and listed in the scoreboard (RMSE results) and those with lower RMSE were better.

### 2.4.1 Model 1 - Baseline  

Model 1 is based only on ratings data and predicts that all userId will give the same rating to all movieId. The average minimizes the RMSE so prediction rating  for this model is the average of all observed ratings.
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE }
#calculating the mean rating value 
m1_mean <- mean(train_edx$rating)
m1_mean
```

The calculated mean rating (m1_mean) is the baseline prediction, and the resulting RMSE calculated on the test_edx data set is as the baseline RMSE (1 Baseline in the table below).
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#result for Model 1 - Baseline
m1_rmse <- RMSE(test_edx$rating, m1_mean)
m1_rmse
```

```{r cache = FALSE, echo=FALSE, message=FALSE, warning=FALSE}
#RMSE calculation and listing in the results table
rmse_table <- tibble(Model="1 Baseline", RMSE=RMSE(test_edx$rating, m1_mean))

#print rmse_table
#kable(rmse_table, caption="RMSE results") %>% kable_styling(latex_options = "hold_position", font_size = 8)
kable(rmse_table, caption="RMSE results" ) %>% kable_styling(latex_options = "HOLD_position", font_size = 8) 
```

The following models trying to achieve the lowest possible RMSE compared to the baseline.

### 2.4.2  Model 2 - Movie Effect  

The movie itself affects the rating, and different movies are rated differently because some movies are more popular than others and users have different preferences. This is movie effect and it means that the average rating on specific movie has a difference from the overall average rating of all movies.  
Train Model 2 for movie effect on train_edx data set:
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#train model for movie effect 
m2_avgs_movie <- 
  train_edx %>% 
  group_by(movieId) %>% 
  summarize(avgs_movie = mean(rating - m1_mean), .groups = "drop")
```
Test Model 2 with movie effect on test_edx data set,
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#test movie effect model
pred_m2_avgs_movie <- m1_mean + test_edx   %>%
  left_join(m2_avgs_movie, by = "movieId") %>%
  .$avgs_movie
```
and calculate RMSE:
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#RMSE calculation and listing in the results table
rmse_table <- bind_rows(rmse_table, tibble(Model = "2 Movie Effect", 
                        RMSE=RMSE(test_edx$rating, pred_m2_avgs_movie)))
```

```{r cache = FALSE, echo=FALSE, message=FALSE, warning=FALSE}
#print rmse_table
#kable(rmse_table, caption="RMSE results") %>% kable_styling(latex_options = "hold_position", font_size = 8)
kable(rmse_table, caption="RMSE results" ) %>% kable_styling(latex_options = "HOLD_position", font_size = 8) 
```

By adding a movie effect, the RMSE is reduced to a value lower than the baseline.


### 2.4.3 Model 3 – Movie and User Effects  

Different users have different ways of rating. Some users give a high rating to each movie, while others always give a low rating.  In Model 3, we use this user effect by adding it to the movie effect from the previous model since both affect rating prediction.

Train Model 3 for movie and user effects on train_edx data set:
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#train model for movie and user effects 
m3_avgs_user <- 
  train_edx %>% 
  left_join(m2_avgs_movie, by = "movieId") %>%
  group_by(userId) %>% 
  summarize(avgs_user = mean(rating - m1_mean - avgs_movie), .groups = "drop")
```

Test Model 3 with movie and user effects on test_edx data set and calculate RMSE:
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#test movie and user effects model
pred_m3_avgs_user <- test_edx %>%
  left_join(m2_avgs_movie, by = "movieId") %>% 
  left_join(m3_avgs_user, by = "userId") %>% 
  mutate(pred_m3 = m1_mean + avgs_movie + avgs_user) %>%
  .$pred_m3
```

```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#RMSE calculation and listing in the results table
rmse_table <- bind_rows(rmse_table, tibble(Model = "3 Movie and User Effects", 
                        RMSE=RMSE(test_edx$rating, pred_m3_avgs_user)))
```

```{r cache = FALSE, echo=FALSE, message=FALSE, warning=FALSE}
#print rmse_table
#kable(rmse_table, caption="RMSE results" ) %>% kable_styling(latex_options = "hold_position", font_size = 8)
kable(rmse_table, caption="RMSE results" ) %>% kable_styling(latex_options = "HOLD_position", font_size = 8) 
```

Adding a user effect to the movie effect considerably improves RMSE compared to the previous model with only a movie effect.


### 2.4.4 Model 4 – Movie, User and Release Year Effects  
  
From the exploration part, it turns out that the movie release year has effect on ratings, so in Model 4, the effect of the year of movie release is added to the effects of the movie and user.

Train Model 4 for movie, user and release year effects on train_edx data set:
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#train model for movie, user and release year effects
m4_avgs_relase <- 
  train_edx %>% 
  left_join(m2_avgs_movie, by = "movieId") %>%
  left_join(m3_avgs_user, by = "userId") %>% 
  group_by(movie_relase_year) %>%
  summarize(avgs_relase = mean(rating - m1_mean - avgs_movie - avgs_user), .groups = "drop")
```

Test Model 4 with movie, user and release year effects on test_edx data set and calculate RMSE:
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#test movie, user and release year effects model
pred_m4_avgs_relase <- test_edx %>%
  left_join(m2_avgs_movie, by = "movieId") %>% 
  left_join(m3_avgs_user, by = "userId") %>% 
  left_join(m4_avgs_relase, by = "movie_relase_year") %>% 
  mutate(pred_m4 = m1_mean + avgs_movie + avgs_user+avgs_relase) %>%
  .$pred_m4
```

```{r cache = FALSE, echo = TRUE, message=TRUE, warning=FALSE}
#RMSE calculation and listing in the results table
rmse_table <- bind_rows(rmse_table, tibble(Model = "4 Movie, User and Release Year Effects", 
                        RMSE=RMSE(test_edx$rating,pred_m4_avgs_relase)))
```

```{r cache = FALSE, echo = FALSE, message=FALSE, warning=FALSE}
#print rmse_table
#kable(rmse_table, caption="RMSE results" ) %>% kable_styling(latex_options = "hold_position", font_size = 8)
kable(rmse_table, caption="RMSE results" ) %>% kable_styling(latex_options = "HOLD_position", font_size = 8) 
```

From the results table above it can be seen that adding the movie release year effect only slightly reduced the RMSE compared to the previous model.


### 2.4.5 Model 5 – Regularized Movie and User Effects  
  
In the data exploration part it is observe that some movies are rated very few times, and there are users who have rated only few times. Sample size for these users and movies is small and this can lead to large estimated error and get worse the RMSE result. In this Model 5, the estimated value is regulated by a penalty factor that is added to penalizes small sample sizes and otherwise has little or no impact.

Next function regularize user and movie effects adding a penalty factor lambda and return RMSE result. This function is used to find optimal lambda value that minimizes the RMSE.
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#regularization function with lambda parameter (movie and user effects)
regularization_m_u2 <- function(lambda, train_set, test_set){
  
  #baseline model
  m1_mean <- mean(train_set$rating)
  
  #train movie effect regularized with lambda
  m2_avgs_movie <-
    train_set %>%
    group_by(movieId) %>%
    summarize(avgs_movie = sum(rating - m1_mean)/(n()+lambda), .groups = "drop")
  
  #train user effect regularized with lambda
  m3_avgs_user <-
    train_set %>%
    left_join(m2_avgs_movie, by = 'movieId') %>%
    group_by(userId) %>%
    summarize(avgs_user = sum(rating - m1_mean - avgs_movie)/(n()+lambda), .groups = "drop")
  
  #test regularized movie and user effects model
  pred_m3_avgs_user <- 
    test_set %>%
    left_join(m2_avgs_movie, by = "movieId") %>%
    left_join(m3_avgs_user, by = "userId") %>%
    mutate(pred_m3 = m1_mean + avgs_movie + avgs_user) %>%
    .$pred_m3
  
  #return RMSE for regularized model with lambda parameter
  return(RMSE(pred_m3_avgs_user, test_set$rating))
}
```
  
First, a set of lambda values is defined, and then the RMSE for each lambda is calculated. Finally, the best lambda resulting in the lowest RMSE for this model was selected to perform the prediction.
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#define a set of lambdas
lambda_set <- seq(0, 10, 0.25)

#calculate RMSE for each lambda
rmses_L <- sapply(lambda_set, regularization_m_u2, 
                  train_set=train_edx, test_set=test_edx)

#take lambda which returns the lowest RMSE, best lambda
lambda <- lambda_set[which.min(rmses_L)]
```
  
Train Model 5 on train_edx data set to calculate the predicted rating using the best lambda parameters achieved from regularization (lambda which return lowest RMSE):
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#train Model 5 using best lambda parameter
#train base lane model
m1_mean <- mean(train_edx$rating)

#train regularized movie effect model
m2_avgs_movie <-
  train_edx %>%
  group_by(movieId) %>%
  summarize(avgs_movie = sum(rating - m1_mean)/(n()+lambda), .groups = "drop")

#train regularized user effect model
m3_avgs_user <-
  train_edx %>%
  left_join(m2_avgs_movie, by = "movieId") %>%
  group_by(userId) %>%
  summarize(avgs_user = sum(rating - m1_mean - avgs_movie)/(n()+lambda), .groups = "drop")
```
  
Test Model 5  with regularized movie and user effects on test_edx data set and calculate RMSE:
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#test regularized model
pred_reg_m3_avgs_user <- test_edx %>%
  left_join(m2_avgs_movie, by = "movieId") %>%
  left_join(m3_avgs_user, by = "userId") %>%
  mutate(pred_m3 = m1_mean + avgs_movie + avgs_user) %>%
  .$pred_m3
```
  
```{r cache = FALSE, echo = TRUE, message=TRUE, warning=FALSE}
#RMSE calculation and listing in the results table
rmse_table <- bind_rows(rmse_table, tibble(Model = "5 Regularized Movie and User Effects", 
                        RMSE=RMSE(test_edx$rating, pred_reg_m3_avgs_user)))
```
  
```{r cache = FALSE, echo = FALSE, message=FALSE, warning=FALSE}
#print rmse_table
#kable(rmse_table, caption="RMSE results" ) %>% kable_styling(latex_options = "hold_position", font_size = 8)
kable(rmse_table, caption="RMSE results" ) %>% kable_styling(latex_options = "HOLD_position", font_size = 8) 
```
  
The result of Model 5, with regularization of movie and user effects, shows little improvement compared to the model without regularization (Model 3).


### 2.4.6 Model 6 – Regularized Movie, User and Release Year Effects  
  
In the same way as in the previous model, in Model 6 regularization is applied to movie, user and release year to penalizes small sample sizes.

First a function which is similar to that in the previous model, is defined to regularize user, movie and release year effects adding a penalty factor lambda and return RMSE result.
```{r cache = FALSE, echo=FALSE, message=FALSE, warning=FALSE}
#regularization function with lambda parameter (movie, user, release effects)
regularization_m_u_r4 <- function(lambda, train_set, test_set){
  
  #baseline model
  m1_mean <- mean(train_set$rating)
  
  #train movie effect regularized with lambda
  m2_avgs_movie <-
    train_set %>%
    group_by(movieId) %>%
    summarize(avgs_movie = sum(rating - m1_mean)/(n()+lambda), .groups = "drop")
  
  #train user effect regularized with lambda
  m3_avgs_user <-
    train_set %>%
    left_join(m2_avgs_movie, by = "movieId") %>%
    group_by(userId) %>%
    summarize(avgs_user = sum(rating - m1_mean - avgs_movie)/(n()+lambda), .groups = "drop")
  
  #train release year effect regularized with lambda
  m4_avgs_relase <-
    train_set %>%
    left_join(m2_avgs_movie, by = "movieId") %>%
    left_join(m3_avgs_user, by = "userId") %>%
    group_by(movie_relase_year) %>%
    summarize(avgs_relase = sum(rating - m1_mean - avgs_movie - avgs_user)/(n()+lambda), .groups = "drop")
  
  #test regularized movie, user and release year effects model
  pred_m4_avgs_relase <- test_set %>%
    left_join(m2_avgs_movie, by = "movieId") %>%
    left_join(m3_avgs_user, by = "userId") %>%
    left_join(m4_avgs_relase, by = "movie_relase_year") %>%
    mutate(pred_m4 = m1_mean + avgs_movie + avgs_user+avgs_relase) %>%
    .$pred_m4
  
  #return RMSE for regularized model with lambda parameter
  return(RMSE(pred_m4_avgs_relase, test_set$rating))
}
```

This function is used to find optimal lambda value that minimizes the RMSE. A set of lambda values is defined, and  the RMSE for each lambda is calculated.
```{r cache = FALSE, echo=FALSE, message=FALSE, warning=FALSE}
#define a set of lambdas
lambda_set <- seq(0, 10, 0.25)

#calculate RMSE for each lambda
rmses_L <- sapply(lambda_set, regularization_m_u_r4,
                  train_set=train_edx, test_set=test_edx)

#take lambda which returns the lowest RMSE, best lambda
#lambda <-        lambda_set[which.min(rmses_L)]
#lambda

#save best lambda for later, for Final validation
lamda_r_m_u_r <- lambda_set[which.min(rmses_L)]
```

The best lambda, resulting in the lowest RMSE for this model, was selected to perform the prediction.
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#take lambda which returns the lowest RMSE, best lambda
lambda <- lambda_set[which.min(rmses_L)]
lambda
```

Than Model 6 is trained on train_edx data set to calculate the predicted rating using the best lambda which return lowest RMSE parameters achieved from regularization on movie, user and release year effects:
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#train model using best lambda parameter

#train base lane model
m1_mean <- mean(train_edx$rating)

#train regularized movie effect model
m2_avgs_movie <-
  train_edx %>%
  group_by(movieId) %>%
  summarize(avgs_movie = sum(rating - m1_mean)/(n()+lambda), .groups = "drop")

#train regularized user effect model
m3_avgs_user <-
  train_edx %>%
  left_join(m2_avgs_movie, by = "movieId") %>%
  group_by(userId) %>%
  summarize(avgs_user = sum(rating - m1_mean - avgs_movie)/(n()+lambda), .groups = "drop")

#train regularized release year effect model
m4_avgs_relase <-
  train_edx %>%
  left_join(m2_avgs_movie, by = "movieId") %>%
  left_join(m3_avgs_user, by = "userId") %>%
  group_by(movie_relase_year) %>%
  summarize(avgs_relase = sum(rating - m1_mean - avgs_movie - avgs_user)/(n()+lambda), .groups = "drop")
```

Test Model 6  with regularized movie, user and release year effects on test_edx data set,
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#test regularized Model 6
pred_reg_m4_avgs_relase <- test_edx %>%
  left_join(m2_avgs_movie, by = "movieId") %>%
  left_join(m3_avgs_user, by = "userId") %>%
  left_join(m4_avgs_relase, by = "movie_relase_year") %>%
  mutate(pred_m4 = m1_mean + avgs_movie + avgs_user+avgs_relase) %>%
  .$pred_m4
```
and calculate RMSE:
```{r cache = FALSE, echo = TRUE, message=TRUE, warning=FALSE}
#RMSE calculation and listing in the results table
rmse_table <- bind_rows(rmse_table, tibble(Model = "6 Regularized Movie, User and Release Effects",
                        RMSE=RMSE(test_edx$rating, pred_reg_m4_avgs_relase)))
```

```{r cache = FALSE, echo = FALSE, message=FALSE, warning=FALSE}
#print rmse_table
#kable(rmse_table, caption="RMSE results" ) %>% kable_styling(latex_options = "hold_position", font_size = 8)
kable(rmse_table, caption="RMSE results" ) %>% kable_styling(latex_options = "HOLD_position", font_size = 8) 
```

The result of Model 6 with regularization of movie, user, and release year shows little improvement over model without regularization (Model 4).

Regularization has improved model prediction performance in both models (Model 5 and 6) but only slightly.


### 2.4.7 Model 7 - Matrix Factorization  

In the recommendation system, users rarely rate all items therefore the rating matrix is sparse. In this Model 7, matrix factorization is used to find hidden patterns in large, sparse user - movie matrix. Matrix factorization decompose a large user - movie matrix into the product of two smaller dimension matrices to discover movie rating patterns and patterns of users who rate movies.

For matrix factorization the recosystem package is used. The rcosystem  (https://cran.r-project.org/web/packages/recosystem/vignettes/introduction.html) provides matrix factorization solution for recommendation system. 

To find predicted values with the recosystem we have to covert data into recosystem input format, 
create model object (Reco), select best parameters, train the model and than compute predicted values.

First, for using train_edx and test_edx data sets in recosystem, they must be organized in 3 columns (user_index, item_index, rating).
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#train_edx and test_edx convert to recosystem column format
mf_train_edx <-  with(train_edx, data_memory(user_index = userId,
                                             item_index = movieId,
                                             rating     = rating))

mf_test_edx  <-  with(test_edx,  data_memory(user_index = userId,
                                             item_index = movieId,
                                             rating     = rating))
```

Then, create Reco model reference object and call the tune method to select best tuning parameters.
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#create model object
mf_reco <-  recosystem::Reco()

#set seed for randomized values 
#find best tuning parameters
#this can take very long execution time
set.seed(123, sample.kind = "Rounding")
opts_2 <- mf_reco$tune(mf_train_edx,  opts = list(dim = c(10, 20, 30), 
                                                  lrate = c(0.1, 0.2),
                                                  costp_l2 = c(0.01, 0.1), 
                                                  costq_l2 = c(0.01, 0.1),
                                                  nthread  = 1, niter = 10))
```

To train Model 7, on train_edx data set, with best tuned parameters, train method is used.
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#train model calling train, with best parameters from tune
mf_reco$train(mf_train_edx, opts = c(opts_2$min, nthread = 1, niter = 20))
```

Test Model 7 and calculate predicted values on test_edx data
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#test Model 7
pred_mf_reco <-  mf_reco$predict(mf_test_edx, out_memory())
head(pred_mf_reco, 5)
```
and calculate RMSE:
```{r cache = FALSE, echo = TRUE, message=TRUE, warning=FALSE}
#RMSE calculation and listing in the results table
rmse_table <- bind_rows(rmse_table, tibble(Model = "7 Matrix Factorization", 
                        RMSE=RMSE(test_edx$rating, pred_mf_reco)))

```

```{r cache = FALSE, echo = FALSE, message=FALSE, warning=FALSE}
#print rmse_table
#kable(rmse_table, caption="RMSE results" ) %>% kable_styling(latex_options = "hold_position", font_size = 8)
kable(rmse_table, caption="RMSE results" ) %>% kable_styling(latex_options = "HOLD_position", font_size = 8) 
```

The result of Model 7 which is based on matrix factorization using the recosysetm package shows substantially improvement compared to all other models.


## 3 Results  

In order to confirm the obtained RMSE results for the two models with the lowest RMSE (Model 6 and Model 7) a final evaluation is conducted over a data set that has not been used so far (validation data set).


### 3.1 Final Validation for Model 6 – Regularized Movie, User and Release Year Effects  

In Model 6 best lambda value that minimizes the RMSE was selected to perform the prediction, and that lambda is used here final Model 6 evaluation.
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#Model 6 best lambda, lamda_r_m_u_r
lamda_r_m_u_r
```

In final validation Model 6 is trained same way like before, using best lambda regularization parameter for movie, user and release year effects but now on edx data set.
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#final train Model 6 using best lambda parameter on edx data set
#train base lane model on edx data set
edx_mean <- mean(edx$rating)

#train regularized movie effect model on edx data set 
m2_avgs_movie <-
  edx %>%
  group_by(movieId) %>%
  summarize(avgs_movie = sum(rating - edx_mean)/(n()+lamda_r_m_u_r), .groups = "drop")

#train regularized user effect model on edx data set 
m3_avgs_user <-
  edx %>%
  left_join(m2_avgs_movie, by = 'movieId') %>%
  group_by(userId) %>%
  summarize(avgs_user = sum(rating - edx_mean - avgs_movie)/(n()+lamda_r_m_u_r), .groups = "drop")

#train regularized release year effect model on edx data set 
m4_avgs_relase <-
  edx %>%
  left_join(m2_avgs_movie, by = 'movieId') %>%
  left_join(m3_avgs_user, by = "userId") %>%
  group_by(movie_relase_year) %>%
  summarize(avgs_relase = sum(rating - edx_mean - avgs_movie - avgs_user)/(n()+lamda_r_m_u_r), .groups = "drop")
```

In the final validation, Model 6 is tested against a validation data set that has not been used in the analysis of this model so far.
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#test regularized Model 6 on validation data set 
final_pred_reg_m4_avgs_relase <- validation %>%
  left_join(m2_avgs_movie, by = "movieId") %>%
  left_join(m3_avgs_user, by = "userId") %>%
  left_join(m4_avgs_relase, by = "movie_relase_year") %>%
  mutate(pred_m4 = edx_mean + avgs_movie + avgs_user + avgs_relase) %>%
  .$pred_m4
```

Calculate RMSE of the final Model 6 evaluation on the edx and validation data set.
```{r cache = FALSE, echo = TRUE, message=TRUE, warning=FALSE}
#RMSE calculation and listing in the results table
rmse_table <- bind_rows(rmse_table, tibble(Model = "8 Final Validation for Model 6 Regularization m+u+r",
                        RMSE=RMSE(validation$rating, final_pred_reg_m4_avgs_relase)))

```

```{r cache = FALSE, echo = FALSE, message=FALSE, warning=FALSE}
#print rmse_table
#kable(rmse_table, caption="RMSE results" ) %>% kable_styling(latex_options = "hold_position", font_size = 8)
kable(rmse_table, caption="RMSE results" ) %>% kable_styling(latex_options = "HOLD_position", font_size = 8) 
```

The table above, in line 8, shows the final result of the validation of Model 6 (Regularized Movie, User and Release Year Effects) which is quite similar to the previously calculated RMSE for Model 6 (line 6 in the table above) and that confirms the RMSE for the model with regularization on the movie, user and release year effect.


### 3.2 Final validation for Model 7 - Matrix Factorization  
  
Previously, in Model 7, matrix factorization model based on recosystem package is resulted with best RMSE result. Here, in the final validation for Model 7, same model with same tuning parameter is used, but now, model is train on the complete edx data set and RMSE is calculated in the validation data set.

In recosystem data sets must be organized in 3 columns (user_index, item_index, rating).
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#edx and validation data set convert to recosystem format
mf_edx <-  with(edx, data_memory(user_index = userId,
                                 item_index = movieId,
                                 rating     = rating))

mf_validation  <-  with(validation,  data_memory(user_index = userId,
                                                 item_index = movieId,
                                                 rating     = rating))
```

Create Reco model reference object and call the tune method to select best tuning parameters.
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE} 
#create model object
mf_reco_final <-  recosystem::Reco()

#set seed for randomized values
#find best tuning parameters
#this  can take very long execution time
set.seed(123, sample.kind = "Rounding")
opts_final <- mf_reco_final$tune(mf_edx,  opts = list(dim = c(10, 20, 30), 
                                                  lrate = c(0.1, 0.2),
                                                  costp_l2 = c(0.01, 0.1), 
                                                  costq_l2 = c(0.01, 0.1),
                                                  nthread  = 1, niter = 10))
```
  
In final validation Model 7 is trained with best tuned parameters on edx data set. 
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#train model calling train, with best parameters from tune
mf_reco_final$train(mf_edx, opts = c(opts_final$min, nthread = 1, niter = 20))
```

In final validation Model 7 is test on validation data.
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#test Model 7 on validation data
pred_mf_reco_final <-  mf_reco_final$predict(mf_validation, out_memory())
head(pred_mf_reco_final, 5)
```

Calculate RMSE of the final Model 7 evaluation on the edx and validation data set:
```{r cache = FALSE, echo = TRUE, message=TRUE, warning=FALSE}
#RMSE calculation and listing in the results table
rmse_table <- bind_rows(rmse_table, tibble(Model = "9 Final Validation for Model 7 Matrix Factorization", 
                        RMSE=RMSE(validation$rating, pred_mf_reco_final)))
```

```{r cache = FALSE, echo = FALSE, message=FALSE, warning=FALSE}
#print rmse_table
#kable(rmse_table, caption="RMSE results" ) %>% kable_styling(latex_options = "hold_position", font_size = 8)
kable(rmse_table, caption="RMSE results" ) %>% kable_styling(latex_options = "HOLD_position", font_size = 8) 
```

The results of final validation for matrix factorization (line 9 in the table above) confirms the RMSE for the Model 7. RMSE results for matrix factorization model are better than the linear models including those with regularization parameters.


### 3.3 Rating prediction for Final Validation  for Model 7 - Matrix Factorization  
  
With the model giving the best result, a recommendation system based on matrix factorization, the rating prediction will be performed on validation data set. The validation set was set aside until the final analysis and here we can use it as a set of userId's for which the movie rating within the set should be predicted. So, we take the validation set as if there is no rating value in it and for the users from that set we predict the rating for the movies that are in that set.
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#prediction with matrix factorization
mf_prediction <- tibble(userId=validation$userId, movieId=validation$movieId, 
                        title = validation$title, rating=validation$rating, 
                        mf_pred_rating = pred_mf_reco_final) %>%
                        arrange(-mf_pred_rating)
```

As we have values for the rating in the validation set, we can now look at the prediction results (mf_pred_rating) in relation to the users rating value that are within the validation set (rating). So, for the 5 highest predicted rating values (mf_pred_rating):
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#top 5, highest predicted rating value
head(mf_prediction, 5)
```


The task of the recommendation is to predict the rating for the movies and to recommend to the user the ones that are predicted to be the most liked. The user - movie matrix from the edx data set contains data on movies and users and blank fields represent movies that users have not rated. If we look at the matrix, we see that for the user we have information about the movies he has rated. For the movies that this user has not rated, there is rating information from other users. As in the example above, we can predict for a user a rating for unrated movies.

Let's take a user (e.g. userId=35305) from an edx data set and predict the ratings for movies from the edx data set that that user didn't rate. Make a list of movies from the edx data set that was not rated by user 35305.
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#list of movies from the edx data set that was not rated by userId=35305

#user 35305 rated movies list
edx_35305 <- edx %>% filter(edx$userId==35305)
movieID_35305 <- unique(edx_35305$movieId)
#edx movie list
edx_movieId <- unique(edx$movieId)

#movies which user 35305 did not rate
a_b <- setdiff( unique(edx$movieId), unique(edx_35305$movieId))
predict_movieId <- data.table(movieId=a_b)
#add movie title information
predict_movieId <- left_join(x = predict_movieId, y = edx) 
# Remove duplicate rows
predict_movieId <- predict_movieId %>% distinct(movieId, .keep_all= TRUE)
#set all list with  userId=35305
predict_movieId$userId[predict_movieId$userId >= 1] <- 35305
#set all list with  rating=NA 
predict_movieId <- predict_movieId %>% 
              replace_with_na(replace = list(rating = c(0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5)))

#list of non rating movies for userId=35305, rating=NA, movieId, title
edx_movieId_set_35305 <- predict_movieId  
#edx_movieId_set_35305  convert to recosystem format
mf_edx_movieId_set_35305  <-  with(edx_movieId_set_35305,  data_memory(user_index = userId,
                                                                       item_index = movieId,
                                                                       rating     = rating))
```

Predict the rating for user 35305:
```{r cache = FALSE, echo=TRUE, message=FALSE, warning=FALSE}
#rating prediction for userId 
pred_mf_edx_movieId_set_35305 <-  mf_reco_final$predict(mf_edx_movieId_set_35305, out_memory())
#head(pred_mf_edx_movieId_set_35305, 5)
mf_prediction_edx_35305 <- tibble(userId=edx_movieId_set_35305$userId, 
                                  movieId=edx_movieId_set_35305$movieId, 
                                  title = edx_movieId_set_35305$title, 
                                  predicted__rating = pred_mf_edx_movieId_set_35305) %>% 
                                  arrange(-predicted__rating )

#top 5 predicted for userId 35305
head(mf_prediction_edx_35305 , 5)
```

The table above shows the 5 movies with the highest predicted rating for the specified user.



## 4 Conclusion  

Throughout the project, several models were compared with respect to the RMSE score (the lower the RMSE the better the model) to create an algorithm for the movie recommendation system.

First, linear models (Model 2, 3, 4) were tested, to which additional information (movie, user, release year) was added based on the analysis of the data set. The next two models (Model 5, 6) used a regularization parameter that penalizes movies and users with a small number of ratings. Final results for linear models is 0.8645223 (8 Final Validation for Model 6 Regularization m+u+r) which is improvement with respect to the baseline (Model 1 Baseline) which is just the average of all observed ratings.

Better results than linear models were achieved by the matrix factorization model, which gave the project the best result and the lowest RMSE value of 0.7828681 (9 Final Validation for Model 7 Matrix Factorization).

To improve the prediction results further, an ensemble method that combines different models can be considered to advance the recommendation system as much as possible.  




## 5 Appendix  

Project related documentation (MovieLens.R, MovieLens_report.Rmd, MovieLens_report.pdf) can be accessed on the GitHub  https://github.com/matej-s/MovieLens . The MovieLens data set used in the project were downloaded from the https://grouplens.org/datasets/movielens/10m/ .

The project used a Windows 10 computer with an i3 processor and 8 GB of RAM. The program code is written in R (version 4.0.2) and RStudio (version 1.3.1073) was used for development. Information collected on the session performed:

sessionInfo()  
R version 4.0.2 (2020-06-22)  
Platform: x86_64-w64-mingw32/x64 (64-bit)  
Running under: Windows 10 x64 (build 18363)  

Matrix products: default  

Random number generation:  
 RNG:     Mersenne-Twister   
 Normal:  Inversion   
 Sample:  Rounding   
   
locale:  
[1] LC_COLLATE=English_United Kingdom.1252  LC_CTYPE=English_United Kingdom.1252  
[3] LC_MONETARY=English_United Kingdom.1252 LC_NUMERIC=C                             
[5] LC_TIME=English_United Kingdom.1252      

attached base packages:  
[1] stats     graphics  grDevices utils     datasets  methods   base       

loaded via a namespace (and not attached):  
 [1] Rcpp_1.0.5       rstudioapi_0.11  knitr_1.29       magrittr_1.5      
 [5] tidyselect_1.1.0 munsell_0.5.0    colorspace_1.4-1 R6_2.4.1          
 [9] rlang_0.4.7      fansi_0.4.1      dplyr_1.0.2      tools_4.0.2       
[13] grid_4.0.2       gtable_0.3.0     xfun_0.16        cli_2.0.2         
[17] htmltools_0.5.0  ellipsis_0.3.1   yaml_2.2.1       digest_0.6.25     
[21] assertthat_0.2.1 tibble_3.0.3     recosystem_0.4.3 lifecycle_0.2.0   
[25] crayon_1.3.4     purrr_0.3.4      ggplot2_3.3.2    vctrs_0.3.2       
[29] evaluate_0.14    glue_1.4.1       rmarkdown_2.3    compiler_4.0.2    
[33] pillar_1.4.6     generics_0.0.2   scales_1.1.1     pkgconfig_2.0.3   


For the described system, generating a pdf document (MovieLens_report.pdf) using the MovieLens_report.Rmd script takes about 3.5 hours, with the most time-consuming, about 90%, falling on the parts related to matrix factorization (2.4.7 Model 7 - Matrix Factorization and 3.2 Final validation for Model 7 Matrix Factorization).  